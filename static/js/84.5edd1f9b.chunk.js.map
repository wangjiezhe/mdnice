{"version":3,"sources":["../node_modules/codemirror/mode/python/python.js"],"names":["CodeMirror","wordRegexp","words","RegExp","join","str","wordOperators","commonKeywords","commonBuiltins","top","state","scopes","length","registerHelper","concat","defineMode","conf","parserConf","ERRORCLASS","delimiters","singleDelimiters","operators","singleOperators","doubleOperators","doubleDelimiters","tripleDelimiters","i","splice","hangingIndent","indentUnit","myKeywords","myBuiltins","undefined","extra_keywords","extra_builtins","py3","version","Number","identifiers","stringPrefixes","keywords","builtins","tokenBase","stream","sol","lastToken","indent","indentation","type","scopeOffset","offset","eatSpace","lineOffset","pushPyScope","dedent","peek","errorToken","style","tokenBaseInner","match","floatLiteral","eat","intLiteral","current","toLowerCase","indexOf","tokenize","delimiter","tokenOuter","charAt","substr","singleline","OUTCLASS","tokenNestedExpr","depth","inner","tokenString","eol","eatWhile","next","singleLineStringErrors","isString","formatStringFactory","tokenStringFactory","pop","push","align","indented","tokenLexer","beginningOfLine","test","lambda","delimiter_index","column","pushBracketScope","slice","startState","basecolumn","token","addErr","textAfter","Pass","scope","closing","electricInput","closeBrackets","triples","lineComment","fold","defineMIME","name","split","mod"],"mappings":"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","file":"static/js/84.5edd1f9b.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  function wordRegexp(words) {\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n  }\n\n  var wordOperators = wordRegexp([\"and\", \"or\", \"not\", \"is\"]);\n  var commonKeywords = [\"as\", \"assert\", \"break\", \"class\", \"continue\", \"def\", \"del\", \"elif\", \"else\", \"except\", \"finally\", \"for\", \"from\", \"global\", \"if\", \"import\", \"lambda\", \"pass\", \"raise\", \"return\", \"try\", \"while\", \"with\", \"yield\", \"in\"];\n  var commonBuiltins = [\"abs\", \"all\", \"any\", \"bin\", \"bool\", \"bytearray\", \"callable\", \"chr\", \"classmethod\", \"compile\", \"complex\", \"delattr\", \"dict\", \"dir\", \"divmod\", \"enumerate\", \"eval\", \"filter\", \"float\", \"format\", \"frozenset\", \"getattr\", \"globals\", \"hasattr\", \"hash\", \"help\", \"hex\", \"id\", \"input\", \"int\", \"isinstance\", \"issubclass\", \"iter\", \"len\", \"list\", \"locals\", \"map\", \"max\", \"memoryview\", \"min\", \"next\", \"object\", \"oct\", \"open\", \"ord\", \"pow\", \"property\", \"range\", \"repr\", \"reversed\", \"round\", \"set\", \"setattr\", \"slice\", \"sorted\", \"staticmethod\", \"str\", \"sum\", \"super\", \"tuple\", \"type\", \"vars\", \"zip\", \"__import__\", \"NotImplemented\", \"Ellipsis\", \"__debug__\"];\n  CodeMirror.registerHelper(\"hintWords\", \"python\", commonKeywords.concat(commonBuiltins));\n\n  function top(state) {\n    return state.scopes[state.scopes.length - 1];\n  }\n\n  CodeMirror.defineMode(\"python\", function (conf, parserConf) {\n    var ERRORCLASS = \"error\";\n    var delimiters = parserConf.delimiters || parserConf.singleDelimiters || /^[\\(\\)\\[\\]\\{\\}@,:`=;\\.\\\\]/; //               (Backwards-compatiblity with old, cumbersome config system)\n\n    var operators = [parserConf.singleOperators, parserConf.doubleOperators, parserConf.doubleDelimiters, parserConf.tripleDelimiters, parserConf.operators || /^([-+*/%\\/&|^]=?|[<>=]+|\\/\\/=?|\\*\\*=?|!=|[~!@]|\\.\\.\\.)/];\n\n    for (var i = 0; i < operators.length; i++) {\n      if (!operators[i]) operators.splice(i--, 1);\n    }\n\n    var hangingIndent = parserConf.hangingIndent || conf.indentUnit;\n    var myKeywords = commonKeywords,\n        myBuiltins = commonBuiltins;\n    if (parserConf.extra_keywords != undefined) myKeywords = myKeywords.concat(parserConf.extra_keywords);\n    if (parserConf.extra_builtins != undefined) myBuiltins = myBuiltins.concat(parserConf.extra_builtins);\n    var py3 = !(parserConf.version && Number(parserConf.version) < 3);\n\n    if (py3) {\n      // since http://legacy.python.org/dev/peps/pep-0465/ @ is also an operator\n      var identifiers = parserConf.identifiers || /^[_A-Za-z\\u00A1-\\uFFFF][_A-Za-z0-9\\u00A1-\\uFFFF]*/;\n      myKeywords = myKeywords.concat([\"nonlocal\", \"False\", \"True\", \"None\", \"async\", \"await\"]);\n      myBuiltins = myBuiltins.concat([\"ascii\", \"bytes\", \"exec\", \"print\"]);\n      var stringPrefixes = new RegExp(\"^(([rbuf]|(br)|(fr))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    } else {\n      var identifiers = parserConf.identifiers || /^[_A-Za-z][_A-Za-z0-9]*/;\n      myKeywords = myKeywords.concat([\"exec\", \"print\"]);\n      myBuiltins = myBuiltins.concat([\"apply\", \"basestring\", \"buffer\", \"cmp\", \"coerce\", \"execfile\", \"file\", \"intern\", \"long\", \"raw_input\", \"reduce\", \"reload\", \"unichr\", \"unicode\", \"xrange\", \"False\", \"True\", \"None\"]);\n      var stringPrefixes = new RegExp(\"^(([rubf]|(ur)|(br))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    }\n\n    var keywords = wordRegexp(myKeywords);\n    var builtins = wordRegexp(myBuiltins); // tokenizers\n\n    function tokenBase(stream, state) {\n      var sol = stream.sol() && state.lastToken != \"\\\\\";\n      if (sol) state.indent = stream.indentation(); // Handle scope changes\n\n      if (sol && top(state).type == \"py\") {\n        var scopeOffset = top(state).offset;\n\n        if (stream.eatSpace()) {\n          var lineOffset = stream.indentation();\n          if (lineOffset > scopeOffset) pushPyScope(state);else if (lineOffset < scopeOffset && dedent(stream, state) && stream.peek() != \"#\") state.errorToken = true;\n          return null;\n        } else {\n          var style = tokenBaseInner(stream, state);\n          if (scopeOffset > 0 && dedent(stream, state)) style += \" \" + ERRORCLASS;\n          return style;\n        }\n      }\n\n      return tokenBaseInner(stream, state);\n    }\n\n    function tokenBaseInner(stream, state) {\n      if (stream.eatSpace()) return null; // Handle Comments\n\n      if (stream.match(/^#.*/)) return \"comment\"; // Handle Number Literals\n\n      if (stream.match(/^[0-9\\.]/, false)) {\n        var floatLiteral = false; // Floats\n\n        if (stream.match(/^[\\d_]*\\.\\d+(e[\\+\\-]?\\d+)?/i)) {\n          floatLiteral = true;\n        }\n\n        if (stream.match(/^[\\d_]+\\.\\d*/)) {\n          floatLiteral = true;\n        }\n\n        if (stream.match(/^\\.\\d+/)) {\n          floatLiteral = true;\n        }\n\n        if (floatLiteral) {\n          // Float literals may be \"imaginary\"\n          stream.eat(/J/i);\n          return \"number\";\n        } // Integers\n\n\n        var intLiteral = false; // Hex\n\n        if (stream.match(/^0x[0-9a-f_]+/i)) intLiteral = true; // Binary\n\n        if (stream.match(/^0b[01_]+/i)) intLiteral = true; // Octal\n\n        if (stream.match(/^0o[0-7_]+/i)) intLiteral = true; // Decimal\n\n        if (stream.match(/^[1-9][\\d_]*(e[\\+\\-]?[\\d_]+)?/)) {\n          // Decimal literals may be \"imaginary\"\n          stream.eat(/J/i); // TODO - Can you have imaginary longs?\n\n          intLiteral = true;\n        } // Zero by itself with no other piece of number.\n\n\n        if (stream.match(/^0(?![\\dx])/i)) intLiteral = true;\n\n        if (intLiteral) {\n          // Integer literals may be \"long\"\n          stream.eat(/L/i);\n          return \"number\";\n        }\n      } // Handle Strings\n\n\n      if (stream.match(stringPrefixes)) {\n        var isFmtString = stream.current().toLowerCase().indexOf('f') !== -1;\n\n        if (!isFmtString) {\n          state.tokenize = tokenStringFactory(stream.current(), state.tokenize);\n          return state.tokenize(stream, state);\n        } else {\n          state.tokenize = formatStringFactory(stream.current(), state.tokenize);\n          return state.tokenize(stream, state);\n        }\n      }\n\n      for (var i = 0; i < operators.length; i++) {\n        if (stream.match(operators[i])) return \"operator\";\n      }\n\n      if (stream.match(delimiters)) return \"punctuation\";\n      if (state.lastToken == \".\" && stream.match(identifiers)) return \"property\";\n      if (stream.match(keywords) || stream.match(wordOperators)) return \"keyword\";\n      if (stream.match(builtins)) return \"builtin\";\n      if (stream.match(/^(self|cls)\\b/)) return \"variable-2\";\n\n      if (stream.match(identifiers)) {\n        if (state.lastToken == \"def\" || state.lastToken == \"class\") return \"def\";\n        return \"variable\";\n      } // Handle non-detected items\n\n\n      stream.next();\n      return ERRORCLASS;\n    }\n\n    function formatStringFactory(delimiter, tokenOuter) {\n      while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0) {\n        delimiter = delimiter.substr(1);\n      }\n\n      var singleline = delimiter.length == 1;\n      var OUTCLASS = \"string\";\n\n      function tokenNestedExpr(depth) {\n        return function (stream, state) {\n          var inner = tokenBaseInner(stream, state);\n\n          if (inner == \"punctuation\") {\n            if (stream.current() == \"{\") {\n              state.tokenize = tokenNestedExpr(depth + 1);\n            } else if (stream.current() == \"}\") {\n              if (depth > 1) state.tokenize = tokenNestedExpr(depth - 1);else state.tokenize = tokenString;\n            }\n          }\n\n          return inner;\n        };\n      }\n\n      function tokenString(stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"\\{\\}\\\\]/);\n\n          if (stream.eat(\"\\\\\")) {\n            stream.next();\n            if (singleline && stream.eol()) return OUTCLASS;\n          } else if (stream.match(delimiter)) {\n            state.tokenize = tokenOuter;\n            return OUTCLASS;\n          } else if (stream.match('{{')) {\n            // ignore {{ in f-str\n            return OUTCLASS;\n          } else if (stream.match('{', false)) {\n            // switch to nested mode\n            state.tokenize = tokenNestedExpr(0);\n            if (stream.current()) return OUTCLASS;else return state.tokenize(stream, state);\n          } else if (stream.match('}}')) {\n            return OUTCLASS;\n          } else if (stream.match('}')) {\n            // single } in f-string is an error\n            return ERRORCLASS;\n          } else {\n            stream.eat(/['\"]/);\n          }\n        }\n\n        if (singleline) {\n          if (parserConf.singleLineStringErrors) return ERRORCLASS;else state.tokenize = tokenOuter;\n        }\n\n        return OUTCLASS;\n      }\n\n      tokenString.isString = true;\n      return tokenString;\n    }\n\n    function tokenStringFactory(delimiter, tokenOuter) {\n      while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0) {\n        delimiter = delimiter.substr(1);\n      }\n\n      var singleline = delimiter.length == 1;\n      var OUTCLASS = \"string\";\n\n      function tokenString(stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"\\\\]/);\n\n          if (stream.eat(\"\\\\\")) {\n            stream.next();\n            if (singleline && stream.eol()) return OUTCLASS;\n          } else if (stream.match(delimiter)) {\n            state.tokenize = tokenOuter;\n            return OUTCLASS;\n          } else {\n            stream.eat(/['\"]/);\n          }\n        }\n\n        if (singleline) {\n          if (parserConf.singleLineStringErrors) return ERRORCLASS;else state.tokenize = tokenOuter;\n        }\n\n        return OUTCLASS;\n      }\n\n      tokenString.isString = true;\n      return tokenString;\n    }\n\n    function pushPyScope(state) {\n      while (top(state).type != \"py\") {\n        state.scopes.pop();\n      }\n\n      state.scopes.push({\n        offset: top(state).offset + conf.indentUnit,\n        type: \"py\",\n        align: null\n      });\n    }\n\n    function pushBracketScope(stream, state, type) {\n      var align = stream.match(/^([\\s\\[\\{\\(]|#.*)*$/, false) ? null : stream.column() + 1;\n      state.scopes.push({\n        offset: state.indent + hangingIndent,\n        type: type,\n        align: align\n      });\n    }\n\n    function dedent(stream, state) {\n      var indented = stream.indentation();\n\n      while (state.scopes.length > 1 && top(state).offset > indented) {\n        if (top(state).type != \"py\") return true;\n        state.scopes.pop();\n      }\n\n      return top(state).offset != indented;\n    }\n\n    function tokenLexer(stream, state) {\n      if (stream.sol()) state.beginningOfLine = true;\n      var style = state.tokenize(stream, state);\n      var current = stream.current(); // Handle decorators\n\n      if (state.beginningOfLine && current == \"@\") return stream.match(identifiers, false) ? \"meta\" : py3 ? \"operator\" : ERRORCLASS;\n      if (/\\S/.test(current)) state.beginningOfLine = false;\n      if ((style == \"variable\" || style == \"builtin\") && state.lastToken == \"meta\") style = \"meta\"; // Handle scope changes.\n\n      if (current == \"pass\" || current == \"return\") state.dedent += 1;\n      if (current == \"lambda\") state.lambda = true;\n      if (current == \":\" && !state.lambda && top(state).type == \"py\") pushPyScope(state);\n\n      if (current.length == 1 && !/string|comment/.test(style)) {\n        var delimiter_index = \"[({\".indexOf(current);\n        if (delimiter_index != -1) pushBracketScope(stream, state, \"])}\".slice(delimiter_index, delimiter_index + 1));\n        delimiter_index = \"])}\".indexOf(current);\n\n        if (delimiter_index != -1) {\n          if (top(state).type == current) state.indent = state.scopes.pop().offset - hangingIndent;else return ERRORCLASS;\n        }\n      }\n\n      if (state.dedent > 0 && stream.eol() && top(state).type == \"py\") {\n        if (state.scopes.length > 1) state.scopes.pop();\n        state.dedent -= 1;\n      }\n\n      return style;\n    }\n\n    var external = {\n      startState: function startState(basecolumn) {\n        return {\n          tokenize: tokenBase,\n          scopes: [{\n            offset: basecolumn || 0,\n            type: \"py\",\n            align: null\n          }],\n          indent: basecolumn || 0,\n          lastToken: null,\n          lambda: false,\n          dedent: 0\n        };\n      },\n      token: function token(stream, state) {\n        var addErr = state.errorToken;\n        if (addErr) state.errorToken = false;\n        var style = tokenLexer(stream, state);\n        if (style && style != \"comment\") state.lastToken = style == \"keyword\" || style == \"punctuation\" ? stream.current() : style;\n        if (style == \"punctuation\") style = null;\n        if (stream.eol() && state.lambda) state.lambda = false;\n        return addErr ? style + \" \" + ERRORCLASS : style;\n      },\n      indent: function indent(state, textAfter) {\n        if (state.tokenize != tokenBase) return state.tokenize.isString ? CodeMirror.Pass : 0;\n        var scope = top(state),\n            closing = scope.type == textAfter.charAt(0);\n        if (scope.align != null) return scope.align - (closing ? 1 : 0);else return scope.offset - (closing ? hangingIndent : 0);\n      },\n      electricInput: /^\\s*[\\}\\]\\)]$/,\n      closeBrackets: {\n        triples: \"'\\\"\"\n      },\n      lineComment: \"#\",\n      fold: \"indent\"\n    };\n    return external;\n  });\n  CodeMirror.defineMIME(\"text/x-python\", \"python\");\n\n  var words = function words(str) {\n    return str.split(\" \");\n  };\n\n  CodeMirror.defineMIME(\"text/x-cython\", {\n    name: \"python\",\n    extra_keywords: words(\"by cdef cimport cpdef ctypedef enum except \" + \"extern gil include nogil property public \" + \"readonly struct union DEF IF ELIF ELSE\")\n  });\n});"],"sourceRoot":""}